objective 11 : 將目前放在Micro SD卡上的系統，作成一個OS Image檔

到目前為止，我們CubieTruck機器上運行的aRuntu 0.888作業系統
已經和我們剛下載來的時候，差異很大了
因為我們不止把它改成中文環境、時區也改了
又安裝上了許多套件（Oracle JDK、Netbeans IDE、gimp、LibreOffice）
然後又讓許多常用的網路服務跑了起來（ssh、vnc、nfs、ftp）
也設定好了gitolite讓它管理/home/git/repositories目錄下的代碼倉庫
現在我們要把目前MicroSD卡的狀態，作成一個OS Image檔
就好像是在一般的PC上面，把硬碟上的作業系統作成一個GHOST或是TrueImage影像檔
然後有需要的時候，就整個把影像檔再restore回硬碟
立刻就回到那個時候作業系統的狀態，不用再一個一個安裝啦設定啦，天都亮了

開始實作，把CubieTruck機器關閉電源，拔出MicroSD卡
插上SD轉卡，然後再插到我筆記型電腦的SD Slot上面

參考了cubieboard官網的這篇教程
http://docs.cubieboard.org/how_to_make_a_sd_image_from_sd_bootable_os

但我沒有完全照抄它的作法，因為上面的官網教程裡，他們用來開機的MicroSD卡有兩個分割區
它把/dev/sdb1分割區的資料擷取出來，包成了bootfs.tar.gz
然後/dev/sdb2分割區的資料擷取出來，包成了rootfs.tar.gz
接著在硬碟上的WORK_DIR目錄裡，作了一個空白的大小約2.38 G的image file
清空最前面1024K的地方
然後從最前面空下來整整8KB，再手動寫入u-boot-sunxi-with-spl.bin
接著再用fdisk指令把image file，也就是/dev/loop0裝置給格式化成兩個分割區
/dev/loop0p1分割區格式化成FAT之後，被取了個別名叫/dev/loop1，再把剛才包的bootfs.tar.gz全解壓縮到/dev/loop1
/dev/loop0p2分割區格式化成EXT4之後，被取了個別名叫/dev/loop2，再把剛才包的rootfs.tar.gz全解壓縮到/dev/loop2
這樣作沒什麼不對，可是因為aRuntu 0.888它只有一個分割區，而且我的aRuntu影像檔需要至少7.2GB的空間
所以我們不能直接照抄cubieboard官網的流程，要稍微改一下
還有我不想先包成rootfs.tar.gz，再解壓縮到loop1裝置上，我想直接TM就直接用dd指令去倒
MicroSD卡上面最前面1024K的地方，我也想直接用dd倒到loop0裝置上
概念大約是這樣

接下來請保持清醒，不要喝酒
還有搞清楚自已的MicroSD卡和筆記型電腦上系統硬碟的磁碟代號
按下ENTER執行指令之前，再三確認一下寫入的來源地和目的地是那裡，想想有沒有什麼問題？
觀念模糊不清時，可能會發生悲劇，要不洗乾淨MicroSD卡，要不就洗乾淨系統硬碟，請打起精神並小心謹慎，要開始製作影像檔了

把MicroSD卡經過SD轉卡，插入筆記型電腦SD Slot之後
到終端機下，執行

先切換成root身分
$ sudo -i

然後看一下MicroSD卡的磁碟代號是什麼
# df -h

終端機打印了
檔案系統        容量  已用  可用 已用% 掛載點
/dev/sda1       453G   93G  338G   22% /
none            4.0K     0  4.0K    0% /sys/fs/cgroup
udev            2.8G  4.0K  2.8G    1% /dev
tmpfs           559M  1.4M  558M    1% /run
none            5.0M     0  5.0M    0% /run/lock
none            2.8G   36M  2.7G    2% /run/shm
none            100M   52K  100M    1% /run/user
/dev/sdb1       7.1G  5.8G  884M   88% /media/anntony/5f70abf0-69bc-468e-b875-5cf1378b476b

這個訊息說明了，我們的MicroSD卡的磁碟代號是/dev/sdb
它有一個分割區叫/dev/sdb1
目前被掛載到/media/anntony/5f70abf0-69bc-468e-b875-5cf1378b476b

卸載它，我不要它被掛載著
# umount /dev/sdb1

再次確認一下是不是真的卸載掉了？
# df -h

終端機打印了
檔案系統        容量  已用  可用 已用% 掛載點
/dev/sda1       453G   93G  338G   22% /
none            4.0K     0  4.0K    0% /sys/fs/cgroup
udev            2.8G  4.0K  2.8G    1% /dev
tmpfs           559M  1.4M  558M    1% /run
none            5.0M     0  5.0M    0% /run/lock
none            2.8G   12M  2.8G    1% /run/shm
none            100M   44K  100M    1% /run/user

很好，真的被卸載掉了
剛才我只是要確定MicroSD卡的磁碟代號
雖然卸載了/dev/sdb，可是MicroSD卡一樣插在筆記型電腦的SD Slot裡
不要去動它，現在來設定一個環境變數card
# card=/dev/sdb

打印一下看看
# echo $card

終端機輸出了
/dev/sdb

這裡要注意的是，你的MicroSD卡的磁碟代號，有可能和我不同
也許你的電腦上有兩顆硬碟，那麼你的MicroSD卡就有可能是/dev/sdc
或是你是把MicroSD卡插在USB讀卡機，再插到筆記型電腦上的
那麼你的MicroSD卡的磁碟代號，就有可能是/dev/mmcblk0
請依照你實際的情況，來設置環境變數card
再次強調，一定要搞清楚自已的MicroSD卡的磁碟代號是什麼
如果你不想要誤洗掉系統硬碟或是其他儲存裝置裡的寶貴資料


繼續，現在看看我人在什麼目錄？
# pwd

終端機回答了
/root

建立一個工作用的目錄
# mkdir WORK_DIR

進入工作目錄
# cd /root/WORK_DIR

再設置一個環境變數image，這是空白影像檔的檔名
# image=aRuntu0888TWv1.img

接著要產生空白影像檔，要多大才夠呢？
看一下MicroSD卡有多大，執行
# fdisk /dev/sdb


終端機提示我們可以按m獲得幫助
您將不能寫入分割表。

命令 (m 以獲得說明)：

那就按個m，再按ENTER鍵
終端機出現了：
命令動作
   a   切換可開機的旗標
   b   編輯 bsd 磁碟標籤
   c   切換 DOS 相容性旗標
   d   刪除分割區
   l   列出已知分割區類型
   m   印出這個選單
   n   加入新的分割區
   o   建立新的空白 DOS 分割表
   p   印出分割表
   q   離開而不需儲存變更
   s   建立新的空白 Sun 磁碟標籤
   t   變更分割區系統識別號
   u   變更顯示/輸入單位
   v   驗證分割表
   w   分割表寫入磁碟然後離開
   x   額外功能 (專家限用)

命令 (m 以獲得說明)： 


我只是路過，和鄉民一起進來看看而已
那就選p，再按下ENTER鍵
終端機打印了分割表如下：
Disk /dev/sdb: 15.7 GB, 15720251392 bytes
64 磁頭，31 磁區/磁軌，15475 磁柱，總計 30703616 磁區
單位 = 磁區 之於 1 * 512 = 512 位元組
磁區大小 (邏輯/實體)：512 位元組 / 512 位元組
I/O 大小 (最小/最佳化)：512 位元組 / 512 位元組
磁碟識別碼：0x00062524

所用裝置 開機      開始         結束      區塊   識別號  系統
/dev/sdb1            2048    15077374     7537663+  83  Linux

命令 (m 以獲得說明)： q

現在我們知道空白影像檔要作多大了，
先關掉fdisk程式，小心並保持頭腦清醒，
以免發生悲劇，像是把MicroSD卡的分割表全洗掉之類的…
我們按下q，再按下ENTER，就這樣悄悄的離開


所以空白影像檔到底要作多大呢？
現在開始小學生的四則運算
15077374 X 512 bytes = 7719615488 bytes = 7538687 KB = 7361.99 MB = 7.189 GB


其實算到7719615488 bytes就夠下指令了，
我只是要讓你知道這個空白影像檔到底有多大
所以才算到GB
如果是MicroSD卡有7719615488 bytes
那麼dd指令的count參數就要大於等於15077374
等等，15077374
這個數字好眼熟
啊不就是上面fdisk指令在打印分割表的時候
2048後面的那個數字15077374嗎？
是的，你答對了，那為什麼你要這樣算那麼長那麼長那麼長
你知道我一秒鐘幾十萬上下嗎？
哦，抱歉
我只是覺得還是應該要說詳細一點，不然你（或是十年後的我）
不清楚這個關鍵數字15077374到底是怎麼來的


終於搞清楚我們需要多大的空白影像檔之後
我們來產生它，執行
# dd if=/dev/zero of=$image count=15077374


大概兩三分鐘之後，終端機輸出了
輸入 15077374+0 個紀錄
輸出 15077374+0 個紀錄
複製了 7719615488 個位元組 (7.7 GB), 96.1057 s, 80.3 MB/s


同步一下，確定空白影像檔寫入硬碟了
# sync


這個剛產生的/root/WORK_DIR/aRuntu0888TWv1.img
就是我們的空白影像檔
接著我們把它和迴路裝置代號/dev/loop0關連起來
# losetup /dev/loop0 $image

確認一下，現在系統裡的/dev/loop0裝置代號是指向什麼東西？
# losetup /dev/loop0

終端機打印了
/dev/loop0: [0801]:25428028 (/root/WORK_DIR/aRuntu0888TWv1.img)

從現在開始，裝置代號
/dev/loop0
就代表我們的空白影像檔/
root/WORK_DIR/aRuntu0888TWv1.img

除了/dev/loop0，我還要再定義一個/dev/loop1的裝置代號
它是以/dev/loop0為基礎，然後前面1024K的地方都空著
我乾脆畫個圖好了，比較好理解

如果下面這個不明條狀物這是我們的/dev/loop0
 _______________________________________________________
|______________________________________________________|

那麼我們的/dev/loop1就會是（黑色區域不算）
_______________________________________________________
|██████____________________________________________|
(1024K)


/dev/loop1
它是
/dev/loop0
的一部分
它跳過影像檔最前面1024K的地方
其他的部分都和/dev/loop0沒兩樣


概念清楚了，回到終端機，我們來定義迴路裝置/dev/loop1，執行
# losetup -o 1048576 /dev/loop1 /dev/loop0


然後再次確認，現在系統裡的
/dev/loop1裝置代號
指向著什麼東西？
# losetup /dev/loop1


終端機輸出了
/dev/loop1: [0005]:1190 (/dev/loop0)，偏移值 1048576

我知道你超想問我
那個1048576又是怎麼來的？
還記得我們說最前面1024K的地方要空著嗎？
還有上面那個fdisk指令
打印分割表給我們看的時候
還記得這一行嗎？
/dev/sdb1            2048    15077374     7537663+  83  Linux
裡面有個2048
那是分割區/dev/sdb1開始的地方
也就是說在分割區/dev/sdb1的前面
磁區0-2047的地方都要空下來
總共有2048個磁區
每個磁區是512 bytes
所以我必須空下來2048 X 512 = 1048576 bytes
然後才是/dev/loop1開始的地方



